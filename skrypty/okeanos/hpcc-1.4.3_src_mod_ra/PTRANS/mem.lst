%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S u m m a r y   R e p o r t
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Compilation
-----------
File     : /lustre/tetyda/home/lgorski/okeanos_scripts/randomaccess/hpcc-1.4.3_src_mod_ra/hpl/lib/arch/build/../../../../PTRANS/mem.c
Compiled : 2016-03-19  13:20:21
Compiler : Version 8.4.5
Ftnlx    : Version 8413 (libcif 84006)
Target   : x86-64
Command  : driver.cc -h cpu=haswell -h static -D __CRAYXC -D __CRAY_HASWELL
           -D __CRAYXT_COMPUTE_LINUX_TARGET -h network=aries
           -o ../../../../PTRANS/mem.o -c ../../../../PTRANS/mem.c
           -I ../../../../include -I ../../../include
           -I ../../../include/CrayX1 -D Add_ -D StringSunStyle
           -D F77_INTEGER=int -O 2 -h list=m -D LONG_IS_64BITS -h restrict=a
           -W l,--rpath=/opt/cray/cce/8.4.5/craylibs/x86-64
           -ibase-compiler /opt/cray/cce/8.4.5/CC/x86-64/compiler_include_base
           -isystem /opt/cray/cce/8.4.5/craylibs/x86-64/include
           -I /opt/gcc/4.8.1/snos/lib/gcc/x86_64-suse-linux/4.8.1/include
           -I /opt/gcc/4.8.1/snos/lib/gcc/x86_64-suse-linux/4.8.1/include-fixed
           -isystem /usr/include
           -I /opt/cray/mpt/7.3.2/gni/mpich-cray/8.3/include
           -I /opt/cray/libsci/16.03.1/CRAY/8.3/x86_64/include
           -I /opt/cray/rca/1.0.0-2.0502.60530.1.62.ari/include
           -I /opt/cray/pmi/5.0.10-1.0000.11050.0.0.ari/include
           -I /opt/cray/xpmem/0.1-2.0502.64982.5.3.ari/include
           -I /opt/cray/dmapp/7.0.1-1.0502.11080.8.76.ari/include
           -I /opt/cray/gni-headers/4.0-1.0502.10859.7.8.ari/include
           -I /opt/cray/ugni/6.0-1.0502.10863.8.29.ari/include
           -I /opt/cray/udreg/2.3.2-1.0502.10518.2.17.ari/include
           -I /opt/cray/cce/8.4.5/craylibs/x86-64/pkgconfig/../include
           -I /opt/cray/cce/8.4.5/craylibs/x86-64/pkgconfig/..//include
           -I /opt/cray/alps/5.2.4-2.0502.9774.31.11.ari/include
           -I /opt/cray/wlm_detect/1.0-1.0502.64649.2.1.ari/include
           -I /opt/cray/alps/5.2.4-2.0502.9774.31.11.ari/include
           -I /opt/cray/krca/1.0.0-2.0502.63139.4.31.ari/include
           -I /opt/cray-hss-devel/7.2.0/include

clx report
------------
Source   : /lustre/tetyda/home/lgorski/okeanos_scripts/randomaccess/hpcc-1.4.3_src_mod_ra/hpl/lib/arch/build/../../../../PTRANS/mem.c
Date     : 03/19/2016  13:20:21


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                          S o u r c e   L i s t i n g
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


     %%%    L o o p m a r k   L e g e n d    %%%

     Primary Loop Type        Modifiers
     ------- ---- ----        ---------
     A - Pattern matched      a - atomic memory operation
                              b - blocked
     C - Collapsed            c - conditional and/or computed
     D - Deleted               
     E - Cloned                
     F - Flat - No calls      f - fused
     G - Accelerated          g - partitioned
     I - Inlined              i - interchanged
     M - Multithreaded        m - partitioned
                              n - non-blocking remote transfer
                              p - partial
                              r - unrolled
                              s - shortloop
     V - Vectorized           w - unwound

     + - More messages listed at end of listing
     ------------------------------------------


    1.              /* -*- mode: C; tab-width: 2; indent-tabs-mode: nil; fill-column: 79; coding: iso-latin-1-unix -*- */
    2.              
    3.              #include <hpcc.h>
    4.              
    5.              static int
    6.              CheckNode(int imrow, int imcol, int nmat, int *mval, int *nval, int nbmat, int *mbval, int *nbval,
    7.                        int myrow, int mycol, int nprow, int npcol, long *maxMem) {
    8.                int i__, ii, m, n, mb, nb, ierr[1];
    9.                int lcm, np0, nq0, mp0, mq0, mg, ng, np, nq, mp, mq;
   10.                long isw, ipw, ipiw, ipa, ipc;
   11.              
   12.                *maxMem = 0;
   13.  + r4------<   for (i__ = 0; i__ < nmat; ++i__) {
   14.    r4            m = mval[i__];
   15.    r4            n = nval[i__];
   16.    r4        
   17.    r4        /*           Make sure matrix information is correct */
   18.    r4        
   19.    r4              ierr[0] = 0;
   20.    r4              if (m < 1) {
   21.    r4                ierr[0] = 1;
   22.    r4              } else if (n < 1) {
   23.    r4                ierr[0] = 1;
   24.    r4              }
   25.    r4        
   26.    r4              if (ierr[0] > 0) {
   27.    r4                continue;
   28.    r4              }
   29.    r4        
   30.  + r4 2----<       for (ii = 0; ii < nbmat; ++ii) { /* Loop over different block sizes */
   31.    r4 2      
   32.    r4 2              mb = mbval[ii];
   33.    r4 2              nb = nbval[ii];
   34.    r4 2      
   35.    r4 2      /*              Make sure blocking sizes are legal */
   36.    r4 2              ierr[0] = 0;
   37.    r4 2              if (mb < 1) {
   38.    r4 2                ierr[0] = 1;
   39.    r4 2              } else if (nb < 1) {
   40.    r4 2                ierr[0] = 1;
   41.    r4 2              }
   42.    r4 2      
   43.    r4 2      /*              Make sure no one had error */
   44.    r4 2      
   45.    r4 2              if (ierr[0] > 0) {
   46.    r4 2                continue;
   47.    r4 2              }
   48.    r4 2      
   49.  + r4 2              mp = numroc_(&m, &mb, &myrow, &imrow, &nprow);
   50.  + r4 2              mq = numroc_(&m, &mb, &mycol, &imcol, &npcol);
   51.  + r4 2              np = numroc_(&n, &nb, &myrow, &imrow, &nprow);
   52.  + r4 2              nq = numroc_(&n, &nb, &mycol, &imcol, &npcol);
   53.    r4 2      
   54.  + r4 2              mg = iceil_(&m, &mb);
   55.  + r4 2              ng = iceil_(&n, &nb);
   56.    r4 2      
   57.  + r4 2              mp0 = iceil_(&mg, &nprow) * mb;
   58.  + r4 2              mq0 = iceil_(&mg, &npcol) * mb;
   59.  + r4 2              np0 = iceil_(&ng, &nprow) * nb;
   60.  + r4 2              nq0 = iceil_(&ng, &npcol) * nb;
   61.    r4 2      
   62.  + r4 2              lcm = ilcm_(&nprow, &npcol);
   63.    r4 2              ipc = 1;
   64.    r4 2              ipa = ipc + (long)np0 * (long)mq0;
   65.    r4 2              ipiw = (long)mp0 * (long)nq0 + ipa;
   66.    r4 2              ipw = ipiw;
   67.  + r4 2              isw = ipw + (long)(iceil_(&mg, &lcm) << 1) * (long)mb * (long)iceil_(&ng, &lcm) * (long)nb;
   68.    r4 2      
   69.    r4 2              if (*maxMem < isw) *maxMem = isw;
   70.    r4 2---->       }
   71.    r4------>   }
   72.                return 0;
   73.              }
   74.              
   75.              int
   76.              MaxMem(int nprocs, int imrow, int imcol, int nmat, int *mval, int *nval, int nbmat, int *mbval,
   77.                     int *nbval, int ngrids, int *npval, int *nqval, long *maxMem) {
   78.                int nprow, npcol, myrow, mycol;
   79.                int j, ierr[1];
   80.                long curMem;
   81.              
   82.                *maxMem = 0;
   83.  + 1-------<   for (j = 0; j < ngrids; ++j) {
   84.    1             nprow = npval[j];
   85.    1             npcol = nqval[j];
   86.    1         
   87.    1         /*        Make sure grid information is correct */
   88.    1         
   89.    1             ierr[0] = 0;
   90.    1             if (nprow < 1) {
   91.    1              ierr[0] = 1;
   92.    1             } else if (npcol < 1) {
   93.    1               ierr[0] = 1;
   94.    1             } else if (nprow * npcol > nprocs) {
   95.    1               ierr[0] = 1;
   96.    1             }
   97.    1         
   98.    1             if (ierr[0] > 0) {
   99.    1               continue;
  100.    1             }
  101.  + 1 2-----<     for (myrow = 0; myrow < nprow; myrow++)
  102.  + 1 2 3---<       for (mycol = 0; mycol < npcol; mycol++) {
  103.  + 1 2 3             CheckNode( imrow, imcol, nmat, mval, nval, nbmat, mbval, nbval, myrow, mycol, nprow,
  104.    1 2 3                        npcol, &curMem );
  105.    1 2 3             if (*maxMem < curMem) *maxMem = curMem;
  106.    1 2 3-->>       }
  107.    1------->   }
  108.                return 0;
  109.              }
  110.              
  111.              #ifdef HPCC_MEMMAIN
  112.              #include <stdio.h>
  113.              int iceil_(int *n,int *d) {return *n>0 ? (*n+*d-1)/ *d : *n/ *d;}
  114.              int numroc_(int *n, int *nb, int *iproc, int *isrcproc, int *nprocs) {
  115.                int ret_val, extrablks, mydist, nblocks;
  116.                mydist = (*nprocs + *iproc - *isrcproc) % *nprocs;
  117.                nblocks = *n / *nb;
  118.                ret_val = nblocks / *nprocs * *nb;
  119.                extrablks = nblocks % *nprocs;
  120.                if (mydist < extrablks) {
  121.                  ret_val += *nb;
  122.                } else if (mydist == extrablks) {
  123.                  ret_val += *n % *nb;
  124.                }
  125.                return ret_val;
  126.              }
  127.              int ilcm_(int *m, int *n) {
  128.                int ret_val;
  129.                int ia, iq, ir;
  130.                if (*m >= *n) {
  131.                  ia = *m;
  132.                  ret_val = *n;
  133.                } else {
  134.                  ia = *n;
  135.                  ret_val = *m;
  136.                }
  137.                for (;;) {
  138.                  iq = ia / ret_val;
  139.                  ir = ia - iq * ret_val;
  140.                  if (ir == 0) {
  141.                    ret_val = *m * *n / ret_val;
  142.                    return ret_val;
  143.                  }
  144.                  ia = ret_val;
  145.                  ret_val = ir;
  146.                }
  147.              }
  148.              int
  149.              main(int argc, char *argv[]) {
  150.                int n, nb, nprow, npcol, ng, lcm;
  151.                int nval[1], nbval[1];
  152.                long maxMem;
  153.              
  154.                if (argc <= 1) {
  155.                  printf( "Usage:\n%s n nb nprow npcol\n", argv[0] );
  156.                }
  157.              
  158.                if (argc <= 1 || sscanf( argv[1], "%d", &n  ) != 1 || n < 1)  n = 50000;
  159.                if (argc <= 2 || sscanf( argv[2], "%d", &nb ) != 1 || nb < 1) nb = 80;
  160.                if (argc <= 3 || sscanf( argv[3], "%d", &nprow ) != 1 || nprow < 1) nprow = 8;
  161.                if (argc <= 4 || sscanf( argv[4], "%d", &npcol ) != 1 || npcol < 1) npcol = nprow;
  162.              
  163.                nval[0] = n;
  164.                nbval[0] = nb;
  165.              
  166.                CheckNode( 0, 0, 1, nval, nval, 1, nbval, nbval, 0, 0, nprow, npcol, &maxMem );
  167.              
  168.                printf( "n=%d nb=%d nprow=%d npcol=%d lcm(nprow,npcol)=%d\n%ld\n", n, nb, nprow, npcol,
  169.                        ilcm_(&nprow, &npcol), maxMem );
  170.              
  171.                ng = iceil_(&n, &nb);
  172.                lcm = ilcm_(&nprow, &npcol);
  173.                printf( "%d %d %d\n", ng, lcm, (iceil_(&ng, &lcm) << 1) * nb * iceil_(&ng, &lcm) * nb );
  174.                printf( "%d %d\n", (iceil_(&ng, &lcm) << 1), iceil_(&ng, &lcm) );
  175.              
  176.                return 0;
  177.              }
  178.              #endif

CC-6287 CC: VECTOR File = mem.c, Line = 13 
  A loop was not vectorized because it contains a call to function "numroc_" on line 49.

CC-6005 CC: SCALAR File = mem.c, Line = 13 
  A loop was unrolled 4 times.

CC-6287 CC: VECTOR File = mem.c, Line = 30 
  A loop was not vectorized because it contains a call to function "numroc_" on line 49.

CC-3021 CC: IPA File = mem.c, Line = 49 
  "numroc_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 50 
  "numroc_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 51 
  "numroc_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 52 
  "numroc_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 54 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 55 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 57 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 58 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 59 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 60 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 62 
  "ilcm_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 67 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-3021 CC: IPA File = mem.c, Line = 67 
  "iceil_" (called from "CheckNode") was not inlined because the compiler was unable to locate the routine.

CC-6287 CC: VECTOR File = mem.c, Line = 83 
  A loop was not vectorized because it contains a call to function "CheckNode" on line 103.

CC-6287 CC: VECTOR File = mem.c, Line = 101 
  A loop was not vectorized because it contains a call to function "CheckNode" on line 103.

CC-6287 CC: VECTOR File = mem.c, Line = 102 
  A loop was not vectorized because it contains a call to function "CheckNode" on line 103.

CC-3118 CC: IPA File = mem.c, Line = 103 
  "CheckNode" (called from "MaxMem") was not inlined because the call site will not flatten.  "iceil_" is missing.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
